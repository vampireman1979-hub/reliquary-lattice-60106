#!/usr/bin/env python3
"""
Lattice Engine v1.0
-------------------
A state-coherence engine with persistent manifest logging and a simple
command-line interface. Designed for experimentation, workflow tracking,
and system-state modeling.

Author: IQNCS
License: MIT
"""

import json
import math
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Dict


# ------------------------------------------------------------
# 1. CONSTANTS
# ------------------------------------------------------------

PHI = (1 + math.sqrt(5)) / 2  # Golden ratio constant
DEFAULT_SCALING = PHI
DEFAULT_MANIFEST_DIR = Path("./lattice_manifests")


# ------------------------------------------------------------
# 2. LATTICE ENGINE CLASS
# ------------------------------------------------------------

@dataclass
class LatticeEngine:
    """
    A coherence-based state engine with persistent manifest logging.

    Attributes:
        coherence (float): System coherence value (0.0 to 1.0).
        scaling (float): Scaling factor applied to coherence.
        access_level (float): Computed access metric.
        events (List[str]): Logged state events.
        history (List[Dict]): Stored manifest entries.
    """

    coherence: float = 0.0
    scaling: float = DEFAULT_SCALING
    access_level: float = 0.0
    events: List[str] = field(default_factory=list)
    history: List[Dict] = field(default_factory=list)

    # --------------------------------------------------------
    # Core Computation
    # --------------------------------------------------------

    def compute_access(self) -> float:
        """
        Computes the access metric based on coherence and scaling.

        Returns:
            float: The computed access level.
        """
        if self.coherence >= 1.0:
            self.access_level = float("inf")
        else:
            self.access_level = self.coherence * self.scaling
        return self.access_level

    # --------------------------------------------------------
    # State Management
    # --------------------------------------------------------

    def set_coherence(self, value: float) -> None:
        """
        Sets the coherence value.

        Args:
            value (float): New coherence value (0.0 to 1.0).
        """
        self.coherence = max(0.0, min(1.0, value))
        self.events.append(f"Coherence set to {self.coherence}")

    def maximize_coherence(self) -> None:
        """
        Sets coherence to maximum (1.0).
        """
        self.coherence = 1.0
        self.events.append("Coherence maximized")

    # --------------------------------------------------------
    # Manifest Logging
    # --------------------------------------------------------

    def save_manifest(self, title: str = "", description: str = "") -> Path:
        """
        Saves a manifest entry to disk.

        Args:
            title (str): Optional manifest title.
            description (str): Optional description.

        Returns:
            Path: Path to the saved manifest file.
        """
        manifest = {
            "title": title or f"manifest_{int(time.time())}",
            "coherence": self.coherence,
            "access_level": self.access_level,
            "scaling": self.scaling,
            "description": description or "No description provided.",
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        }

        DEFAULT_MANIFEST_DIR.mkdir(parents=True, exist_ok=True)
        path = DEFAULT_MANIFEST_DIR / f"{manifest['title']}.json"

        with path.open("w") as f:
            json.dump(manifest, f, indent=4)

        self.history.append(manifest)
        self.events.append(f"Manifest saved: {path.name}")

        print(f"Manifest saved → {path}")
        return path

    # --------------------------------------------------------
    # Display
    # --------------------------------------------------------

    def display_state(self) -> None:
        """
        Prints the current engine state.
        """
        print("\n--- Lattice Engine State ---")
        print(f"Coherence:      {self.coherence:.4f}")
        print(f"Scaling Factor: {self.scaling:.6f}")
        print(f"Access Level:   {self.access_level}")
        print(f"Events Logged:  {len(self.events)}")
        print(f"Manifests:      {len(self.history)}")
        print("-----------------------------\n")


# ------------------------------------------------------------
# 3. COMMAND-LINE INTERFACE
# ------------------------------------------------------------

def lattice_cli() -> None:
    """
    Command-line interface for interacting with the Lattice Engine.
    """
    engine = LatticeEngine()

    print("\nLattice Engine v1.0")
    print("State-Coherence Modeling Interface\n")

    while True:
        cmd = input("Command (access / set / max / seal / state / quit): ").strip().lower()

        if cmd == "quit":
            print("Exiting Lattice Engine.")
            break

        elif cmd == "state":
            engine.display_state()

        elif cmd == "access":
            engine.compute_access()
            print(f"Access Level: {engine.access_level}")

        elif cmd == "set":
            try:
                value = float(input("Enter coherence value (0.0–1.0): "))
                engine.set_coherence(value)
            except ValueError:
                print("Invalid input. Enter a numeric value.")

        elif cmd == "max":
            engine.maximize_coherence()
            engine.compute_access()
            print("Coherence maximized.")

        elif cmd == "seal":
            title = input("Manifest Title (optional): ").strip()
            desc = input("Description (optional): ").strip()
            engine.compute_access()
            engine.save_manifest(title, desc)

        else:
            print("Commands: access / set / max / seal / state / quit")


# ------------------------------------------------------------
# Entry Point
# ------------------------------------------------------------

if __name__ == "__main__":
    lattice_cli()
